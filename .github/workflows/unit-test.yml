name: $(Build.SourceBranchName)_$(Build.Reason)_$(majorVersion).$(Build.BuildId)$(Rev:.r)

# Enable CI and PR validation on branches master and dev
on:
  push:
    branches: [ master, dev, pipeline-github-actions ]
  pull_request:
    branches: [ master, dev, pipeline-github-actions ]

env:
  
  RunTestsOnly: false
  
  # Major version
  majorVersion: 1.0.0

  # image tag prefix for master branch (0.2.0)
  MASTER_IMAGE_TAG: ''

  # image tag prefix for dev branch (0.3.0-dev)
  DEV_IMAGE_TAG: dev

  buildConfiguration: 'Release'

  edgeAgentVersion: 1.0.7
  edgeHubVersion: 1.0.7
  edgeHubRoute: FROM /* INTO $upstream

  # Defines the name of the VSTS agent in ARM architecture
  vstsAgentARM: myAgent-arm32v7

  # Defines the name of the VSTS agent in AMD64 architecture
  vstsAgentAMD: myAgent-amd64

  # Network Server module level: 1 in order to get decoder information
  networkServerLogLevel: 1

  # Azure Function configuration
  AZURE_FUNCTIONAPP_NAME: ms-lora-function-app
  AZURE_FUNCTIONAPP_PACKAGE_PATH: 'LoRaEngine/LoraKeysManagerFacade/'

  # IoT Edge Runtime configuration
  EDGE_AGENT_VERSION: $(edgeAgentVersion)
  EDGE_HUB_VERSION: $(edgeHubVersion)
  EDGEHUB_OPTIMIZEFORPERFORMANCE: false
  EDGEHUB_MQTTSETTINGS_ENABLED: false
  EDGEHUB_HTTPSETTINGS_ENABLED: false
  EDGEHUB_ROUTE: $(edgeHubRoute)
  
  # Integration test configuration
  IoTEdgeDeviceAMD: ''
  
  # LoRaWan Modules
  NET_SRV_LOG_LEVEL: $(networkServerLogLevel)  
  NET_SRV_LOGTO_UDP: true
  NET_SRV_LOGTO_HUB: false
  NET_SRV_IOTEDGE_TIMEOUT: 0
  NET_SRV_VERSION: "" # Network Server module version
  NET_SRV_LOG_TO_UDP_ADDRESS: 10.164.74.151 # Hostname of test runner
  PKT_FWD_VERSION: "" # Packet Forward module version
  
jobs:

  # [Job] Smoke test job: ensure code compiles and unit tests are working
  build_and_test:
    name: Build and Test Solution
    runs-on: ubuntu-16.04
    
    steps:
    # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
    - uses: actions/checkout@v2
      
    # build LoRa Engine
    - name: Build LoRa Engine
      if: env.RunTestsOnly != 'true'
      run: dotnet build --configuration ${{ env.buildConfiguration }} LoRaEngine/LoRaEngine.sln

#     # build C# Samples/DecoderSample
#     - name: Build C# Samples/DecoderSample
#       if: env.RunTestsOnly != 'true'
#       run: dotnet build --configuration ${{ env.buildConfiguration }} Samples/DecoderSample 

#     # build LoRa Simulator
#     - name: Build LoRa Simulator
#       if: env.RunTestsOnly != 'true'
#       run: dotnet build --configuration ${{ env.buildConfiguration }} LoRaEngine/modules/LoRaSimulator/LoRaSimulator.sln

#     # Pull Redis Cache docker image
#     - name: Pulling Redis Cache image
#       if: env.RunTestsOnly != 'true'
#       run: docker pull redis:5.0.4-alpine

#     # Run unit tests
#     - name: Run unit tests
#       run: |
#         mkdir $(Build.SourcesDirectory)\results
#         dotnet test --logger trx LoRaEngine/test/LoRaWanNetworkServer.Test/*.csproj &&  dotnet test --logger trx LoRaEngine/modules/LoRaWanNetworkSrvModule/LoRaToolsTest/*.csproj && dotnet test --logger trx LoRaEngine/test/LoraKeysManagerFacade.Test/*.csproj
   
#     # Find out if full ci is enabled for Pull Request validation
#     - name: Check for CI label build on PR
#       run: |
#         echo "Looking for label at https://api.github.com/repos/$BUILD_REPOSITORY_ID/issues/$SYSTEM_PULLREQUEST_PULLREQUESTNUMBER/labels"
#         if curl -s "https://api.github.com/repos/$BUILD_REPOSITORY_ID/issues/$SYSTEM_PULLREQUEST_PULLREQUESTNUMBER/labels" | grep '"name": "fullci"'
#         then
#           echo "::set-output name=prWithCILabel::true"       
#           echo "fullci label found!"
#         fi
#       if: github.event_name == 'pull_request'
   
  # [Job] Build and deploy Facade Azure Function 
#   full_ci_deploy_facade_function:
#     name: Build and deploy Facade Azure Function   
#     needs: build_and_test
#     runs-on: ubuntu-16.04

#     steps:
#        - uses: actions/checkout@v2
         
#        - name: 'Resolve Project Dependencies Using Dotnet'
#          shell: bash
#          run: |
#            pushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
#            dotnet build --configuration Release --output ./output
#            popd
           
#        - name: 'Run Azure Functions Action'
#          uses: Azure/functions-action@v1
#          id: fa
#          with:
#            app-name: ${{ env.AZURE_FUNCTIONAPP_NAME }}
#            package: '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/output'
#            publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE }}
